export class GCodeGenerator {
    constructor() {
        this.gcode = [];
    }

    generate(paths, config) {
        this.gcode = [];
        
        // Header
        this.addComment('Generated by GRBL Web Control Pro');
        this.addComment('Date: ' + new Date().toLocaleString());
        this.addComment('Operation: ' + config.operationType);
        this.addComment('');
        
        // Initialize
        this.addLine('G21'); // Millimeters
        this.addLine('G90'); // Absolute positioning
        
        if (config.operationType === 'laser') {
            this.addLine('M3 S0'); // Laser mode
            this.addComment('');
        } else {
            this.addLine('M3 S' + config.spindleRPM); // Spindle on
            this.addLine('G0 Z5'); // Safe height
            this.addComment('');
        }

        // Process each path
        paths.forEach((path, index) => {
            this.addComment(`Path ${index + 1}`);
            
            if (config.operationType === 'laser') {
                this.generateLaserPath(path, config);
            } else {
                this.generateCNCPath(path, config);
            }
            
            this.addComment('');
        });

        // Footer
        if (config.operationType === 'laser') {
            this.addLine('M5'); // Laser off
        } else {
            this.addLine('G0 Z5'); // Lift tool
            this.addLine('M5'); // Spindle off
        }
        
        this.addLine('G0 X0 Y0'); // Return to origin
        this.addLine('M2'); // End program
        
        return this.gcode.join('\n');
    }

    generateLaserPath(path, config) {
        const power = Math.round((config.laserPower / 100) * 1000);
        let isFirst = true;
        
        path.segments.forEach(seg => {
            if (isFirst || seg.type === 'move') {
                // Move with laser off
                this.addLine(`G0 X${seg.x.toFixed(3)} Y${seg.y.toFixed(3)} S0`);
                isFirst = false;
            } else {
                // Cut with laser on
                this.addLine(`G1 X${seg.x.toFixed(3)} Y${seg.y.toFixed(3)} F${config.feedRate} S${power}`);
            }
        });
        
        // Turn off laser
        this.addLine('M5');
    }

    generateCNCPath(path, config) {
        const totalDepth = Math.abs(config.depth);
        const depthStep = Math.abs(config.depthStep);
        const passes = Math.ceil(totalDepth / depthStep);
        
        for (let pass = 1; pass <= passes; pass++) {
            const currentDepth = Math.min(pass * depthStep, totalDepth);
            this.addComment(`Pass ${pass}/${passes} - Depth: -${currentDepth.toFixed(2)}mm`);
            
            let isFirst = true;
            
            path.segments.forEach(seg => {
                if (isFirst || seg.type === 'move') {
                    // Lift and rapid to position
                    if (!isFirst) {
                        this.addLine('G0 Z5');
                    }
                    this.addLine(`G0 X${seg.x.toFixed(3)} Y${seg.y.toFixed(3)}`);
                    
                    // Plunge
                    this.addLine(`G1 Z${(-currentDepth).toFixed(3)} F${config.plungeRate}`);
                    isFirst = false;
                } else {
                    // Cutting move
                    this.addLine(`G1 X${seg.x.toFixed(3)} Y${seg.y.toFixed(3)} F${config.feedRate}`);
                }
            });
            
            this.addLine('G0 Z5'); // Lift after pass
        }
    }

    addLine(line) {
        this.gcode.push(line);
    }

    addComment(comment) {
        if (comment) {
            this.gcode.push('; ' + comment);
        } else {
            this.gcode.push('');
        }
    }

    calculateEstimates(gcode, config) {
        const lines = gcode.split('\n').filter(l => l.trim() && !l.startsWith(';'));
        
        let totalDistance = 0;
        let totalTime = 0;
        let currentX = 0, currentY = 0, currentZ = 0;
        let currentFeed = config.feedRate;
        
        lines.forEach(line => {
            // Parse G0/G1 commands
            const g0Match = line.match(/G0\s+X([-\d.]+)\s+Y([-\d.]+)/i);
            const g1Match = line.match(/G1\s+X([-\d.]+)\s+Y([-\d.]+)/i);
            const g1zMatch = line.match(/G1\s+Z([-\d.]+)/i);
            const feedMatch = line.match(/F([\d.]+)/i);
            
            if (feedMatch) {
                currentFeed = parseFloat(feedMatch[1]);
            }
            
            if (g0Match) {
                const x = parseFloat(g0Match[1]);
                const y = parseFloat(g0Match[2]);
                const distance = Math.sqrt(Math.pow(x - currentX, 2) + Math.pow(y - currentY, 2));
                totalDistance += distance;
                totalTime += (distance / 3000) * 60; // Rapid at 3000mm/min
                currentX = x;
                currentY = y;
            } else if (g1Match) {
                const x = parseFloat(g1Match[1]);
                const y = parseFloat(g1Match[2]);
                const distance = Math.sqrt(Math.pow(x - currentX, 2) + Math.pow(y - currentY, 2));
                totalDistance += distance;
                totalTime += (distance / currentFeed) * 60;
                currentX = x;
                currentY = y;
            } else if (g1zMatch) {
                const z = parseFloat(g1zMatch[1]);
                const distance = Math.abs(z - currentZ);
                totalTime += (distance / (config.plungeRate || currentFeed)) * 60;
                currentZ = z;
            }
        });
        
        return {
            distance: totalDistance,
            time: totalTime
        };
    }
}

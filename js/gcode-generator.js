// ============================================
// G-CODE GENERATOR - REAL IMPLEMENTATION
// ============================================
class GCodeGenerator {
    constructor() {
        this.gcode = '';
        this.totalDistance = 0;
        this.totalTime = 0;
    }

    generate(paths, config, operationType) {
        console.log('üîß Generating G-code...');
        console.log('   Paths:', paths.length);
        console.log('   Type:', operationType);
        console.log('   Config:', config);

        this.totalDistance = 0;
        this.totalTime = 0;

        const lines = [];

        // ====================================
        // HEADER
        // ====================================
        lines.push('; Generated by GRBL Web Control Pro v4.0');
        lines.push(`; Date: ${new Date().toISOString()}`);
        lines.push(`; Operation: ${operationType.toUpperCase()}`);
        lines.push('; ====================================');
        lines.push('');

        // Setup
        lines.push('G21 ; Set units to millimeters');
        lines.push('G90 ; Absolute positioning');
        lines.push('G17 ; XY plane selection');
        lines.push('');

        if (operationType === 'cnc') {
            lines.push(`M3 S${config.spindleRPM} ; Start spindle at ${config.spindleRPM} RPM`);
            lines.push('G4 P2 ; Wait 2 seconds for spindle to reach speed');
        } else if (operationType === 'laser') {
            lines.push('M3 S0 ; Laser mode, initially off');
            lines.push('G4 P0.5 ; Brief pause');
        }

        lines.push('');
        lines.push(`G0 Z5 F${config.feedRate} ; Move to safe height`);
        lines.push('G0 X0 Y0 ; Move to origin');
        lines.push('');

        // ====================================
        // GENERATE TOOLPATHS
        // ====================================
        if (paths.length === 0) {
            lines.push('; ERROR: No paths to process');
            console.warn('‚ö†Ô∏è No paths provided');
        } else {
            if (operationType === 'cnc') {
                lines.push(...this.generateCNCToolpath(paths, config));
            } else if (operationType === 'laser') {
                lines.push(...this.generateLaserToolpath(paths, config));
            }
        }

        // ====================================
        // FOOTER
        // ====================================
        lines.push('');
        lines.push('; ====================================');
        lines.push('; END OF PROGRAM');
        lines.push('; ====================================');
        lines.push('');
        lines.push('G0 Z10 ; Raise to safe height');

        if (operationType === 'laser') {
            lines.push('M5 ; Turn off laser');
        } else {
            lines.push('M5 ; Stop spindle');
        }

        lines.push('G0 X0 Y0 ; Return to origin');
        lines.push('M2 ; End program');
        lines.push('');

        this.gcode = lines.join('\n');

        console.log('‚úÖ G-code generated');
        console.log('   Lines:', lines.length);
        console.log('   Distance:', this.totalDistance.toFixed(2), 'mm');
        console.log('   Estimated time:', this.totalTime.toFixed(0), 'seconds');

        return this.gcode;
    }

    // ====================================
    // CNC TOOLPATH (Multi-pass with tool compensation)
    // ====================================
    generateCNCToolpath(paths, config) {
        const lines = [];
        const depth = parseFloat(config.depth);
        const depthStep = parseFloat(config.depthStep);
        const toolRadius = parseFloat(config.toolDiameter) / 2;
        const feedRate = parseFloat(config.feedRate);
        const plungeRate = parseFloat(config.plungeRate);
        const compensation = config.compensation;

        // Calculate number of passes
        const numPasses = Math.ceil(Math.abs(depth) / depthStep);

        lines.push(`; CNC TOOLPATH - ${numPasses} passes`);
        lines.push(`; Total depth: ${depth}mm in ${depthStep}mm steps`);
        lines.push(`; Tool diameter: ${config.toolDiameter}mm (radius: ${toolRadius}mm)`);
        lines.push(`; Compensation: ${compensation}`);
        lines.push('');

        // Process each pass
        for (let pass = 1; pass <= numPasses; pass++) {
            const currentDepth = -Math.min(Math.abs(depth), depthStep * pass);

            lines.push('');
            lines.push(`; ====================================`);
            lines.push(`; PASS ${pass}/${numPasses} - Depth: ${currentDepth.toFixed(3)}mm`);
            lines.push(`; ====================================`);
            lines.push('');

            // Process each path
            paths.forEach((path, pathIndex) => {
                lines.push(`; Path ${pathIndex + 1} (${path.points.length} points)`);

                // Apply tool compensation if needed
                let processedPoints = path.points;
                if (compensation !== 'center' && toolRadius > 0) {
                    processedPoints = this.applyToolCompensation(
                        path.points,
                        toolRadius,
                        compensation === 'outside' ? 1 : -1,
                        path.closed
                    );
                }

                if (processedPoints.length === 0) {
                    lines.push('; Warning: Path has no points after compensation');
                    return;
                }

                // Move to start point (rapid, at safe height)
                const startPoint = processedPoints[0];
                lines.push(`G0 X${startPoint.x.toFixed(3)} Y${startPoint.y.toFixed(3)} ; Rapid to start`);

                // Plunge to depth
                lines.push(`G1 Z${currentDepth.toFixed(3)} F${plungeRate} ; Plunge`);

                // Cut the path
                for (let i = 1; i < processedPoints.length; i++) {
                    const pt = processedPoints[i];
                    lines.push(`G1 X${pt.x.toFixed(3)} Y${pt.y.toFixed(3)} F${feedRate}`);

                    // Calculate distance for estimates
                    const prevPt = processedPoints[i - 1];
                    const dist = this.distance(prevPt, pt);
                    this.totalDistance += dist;
                    this.totalTime += (dist / feedRate) * 60; // Convert to seconds
                }

                // Retract to safe height
                lines.push(`G0 Z5 ; Retract`);
                lines.push('');
            });
        }

        return lines;
    }

    // ====================================
    // LASER TOOLPATH (Single pass, no compensation)
    // ====================================
    generateLaserToolpath(paths, config) {
        const lines = [];
        const feedRate = parseFloat(config.feedRate);
        const laserPower = parseFloat(config.laserPower);
        const laserS = Math.round((laserPower / 100) * 1000); // 0-1000 scale for GRBL

        lines.push(`; LASER TOOLPATH`);
        lines.push(`; Power: ${laserPower}% (S${laserS})`);
        lines.push(`; Feed rate: ${feedRate} mm/min`);
        lines.push('');

        // Process each path
        paths.forEach((path, pathIndex) => {
            lines.push(`; Path ${pathIndex + 1} (${path.points.length} points)`);

            if (path.points.length === 0) {
                lines.push('; Warning: Empty path');
                return;
            }

            // Move to start point with laser off
            const startPoint = path.points[0];
            lines.push(`G0 X${startPoint.x.toFixed(3)} Y${startPoint.y.toFixed(3)} ; Rapid to start`);
            lines.push(`M3 S${laserS} ; Laser on at ${laserPower}%`);

            // Burn the path
            for (let i = 1; i < path.points.length; i++) {
                const pt = path.points[i];
                lines.push(`G1 X${pt.x.toFixed(3)} Y${pt.y.toFixed(3)} F${feedRate}`);

                // Calculate distance for estimates
                const prevPt = path.points[i - 1];
                const dist = this.distance(prevPt, pt);
                this.totalDistance += dist;
                this.totalTime += (dist / feedRate) * 60; // Convert to seconds
            }

            // Laser off
            lines.push(`M3 S0 ; Laser off`);
            lines.push('');
        });

        return lines;
    }

    // ====================================
    // TOOL COMPENSATION (Offset paths)
    // ====================================
    applyToolCompensation(points, radius, direction, closed) {
        // Simple offset algorithm
        // direction: 1 = outside, -1 = inside

        if (points.length < 2) return points;

        const offsetPoints = [];

        for (let i = 0; i < points.length; i++) {
            const prevIndex = i === 0 ? (closed ? points.length - 1 : 0) : i - 1;
            const nextIndex = i === points.length - 1 ? (closed ? 0 : i) : i + 1;

            const prev = points[prevIndex];
            const current = points[i];
            const next = points[nextIndex];

            // Calculate offset normal vector
            let normalX = 0;
            let normalY = 0;

            if (i === 0 && !closed) {
                // First point (open path): use only forward direction
                const dx = next.x - current.x;
                const dy = next.y - current.y;
                const len = Math.sqrt(dx * dx + dy * dy);
                if (len > 0) {
                    normalX = -dy / len;
                    normalY = dx / len;
                }
            } else if (i === points.length - 1 && !closed) {
                // Last point (open path): use only backward direction
                const dx = current.x - prev.x;
                const dy = current.y - prev.y;
                const len = Math.sqrt(dx * dx + dy * dy);
                if (len > 0) {
                    normalX = -dy / len;
                    normalY = dx / len;
                }
            } else {
                // Middle points or closed path: average of two normals
                const dx1 = current.x - prev.x;
                const dy1 = current.y - prev.y;
                const len1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);

                const dx2 = next.x - current.x;
                const dy2 = next.y - current.y;
                const len2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);

                if (len1 > 0 && len2 > 0) {
                    const n1x = -dy1 / len1;
                    const n1y = dx1 / len1;
                    const n2x = -dy2 / len2;
                    const n2y = dx2 / len2;

                    normalX = (n1x + n2x) / 2;
                    normalY = (n1y + n2y) / 2;

                    // Normalize
                    const normalLen = Math.sqrt(normalX * normalX + normalY * normalY);
                    if (normalLen > 0) {
                        normalX /= normalLen;
                        normalY /= normalLen;
                    }
                }
            }

            // Apply offset
            const offsetX = current.x + normalX * radius * direction;
            const offsetY = current.y + normalY * radius * direction;

            offsetPoints.push({
                x: parseFloat(offsetX.toFixed(3)),
                              y: parseFloat(offsetY.toFixed(3))
            });
        }

        return offsetPoints;
    }

    // ====================================
    // UTILITIES
    // ====================================
    distance(p1, p2) {
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        return Math.sqrt(dx * dx + dy * dy);
    }

    calculateEstimates(gcode, config) {
        // Return cached values from generation
        return {
            distance: this.totalDistance,
            time: this.totalTime
        };
    }
}

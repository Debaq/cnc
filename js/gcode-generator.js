export class GCodeGenerator {
    constructor(app) {
        this.app = app;
    }
    
    generate(paths, config, operationType) {
        let gcode = [];
        
        // Header
        gcode.push('(Generated by GRBL Web Control Pro v3.0)');
        gcode.push(`(Date: ${new Date().toISOString()})`);
        gcode.push(`(Operation: ${operationType})`);
        gcode.push('');
        
        // Initialize
        gcode.push('G21 ; Set units to millimeters');
        gcode.push('G90 ; Absolute positioning');
        gcode.push('G17 ; XY plane selection');
        
        if (operationType === 'cnc') {
            gcode = gcode.concat(this.generateCNC(paths, config));
        } else if (operationType === 'laser') {
            gcode = gcode.concat(this.generateLaser(paths, config));
        }
        
        // Footer
        gcode.push('');
        gcode.push('M5 ; Stop spindle/laser');
        gcode.push('G0 Z10 ; Raise Z');
        gcode.push('G0 X0 Y0 ; Return to origin');
        gcode.push('M2 ; End program');
        
        return gcode.join('\n');
    }
    
    generateCNC(paths, config) {
        const gcode = [];
        const {
            depth,
            depthStep,
            toolDiameter,
            compensation,
            feedRate,
            plungeRate,
            spindleRPM
        } = config;
        
        gcode.push('');
        gcode.push('(CNC Milling Operation)');
        gcode.push(`(Tool Diameter: ${toolDiameter}mm)`);
        gcode.push(`(Depth: ${depth}mm, Step: ${depthStep}mm)`);
        gcode.push(`(Feed Rate: ${feedRate}mm/min)`);
        gcode.push('');
        
        // Start spindle
        gcode.push(`M3 S${spindleRPM} ; Start spindle`);
        gcode.push('G4 P2 ; Wait 2 seconds for spindle');
        gcode.push('');
        
        // Calculate number of passes
        const numPasses = Math.ceil(Math.abs(depth) / depthStep);
        
        // Process each path
        paths.forEach((path, pathIndex) => {
            if (path.points.length < 2) return;
            
            gcode.push(`(Path ${pathIndex + 1})`);
            
            // Apply tool compensation if needed
            let processedPath = path.points;
            if (compensation !== 'center' && path.closed) {
                processedPath = this.applyToolCompensation(
                    path.points,
                    toolDiameter / 2,
                    compensation === 'outside'
                );
            }
            
            // Execute multiple depth passes
            for (let pass = 1; pass <= numPasses; pass++) {
                const currentDepth = -Math.min(pass * depthStep, Math.abs(depth));
                
                gcode.push(`(Pass ${pass}/${numPasses}, Depth: ${currentDepth.toFixed(3)}mm)`);
                
                // Move to start point (raised)
                const startPoint = processedPath[0];
                gcode.push(`G0 X${startPoint.x.toFixed(3)} Y${startPoint.y.toFixed(3)} ; Rapid to start`);
                gcode.push(`G0 Z2 ; Safe height`);
                
                // Plunge
                gcode.push(`G1 Z${currentDepth.toFixed(3)} F${plungeRate} ; Plunge`);
                
                // Cut path
                for (let i = 1; i < processedPath.length; i++) {
                    const point = processedPath[i];
                    gcode.push(`G1 X${point.x.toFixed(3)} Y${point.y.toFixed(3)} F${feedRate}`);
                }
                
                // Retract
                gcode.push('G0 Z2 ; Retract');
                gcode.push('');
            }
        });
        
        return gcode;
    }
    
    generateLaser(paths, config) {
        const gcode = [];
        const {
            feedRate,
            laserPower
        } = config;
        
        gcode.push('');
        gcode.push('(Laser Cutting/Engraving Operation)');
        gcode.push(`(Laser Power: ${laserPower}%)`);
        gcode.push(`(Feed Rate: ${feedRate}mm/min)`);
        gcode.push('');
        
        gcode.push('M3 S0 ; Laser mode, off');
        gcode.push('G0 Z0 ; Z to working height');
        gcode.push('');
        
        // Calculate laser power (0-1000 for most controllers)
        const laserS = Math.round((laserPower / 100) * 1000);
        
        // Process each path
        paths.forEach((path, pathIndex) => {
            if (path.points.length < 2) return;
            
            gcode.push(`(Path ${pathIndex + 1})`);
            
            // Move to start point (laser off)
            const startPoint = path.points[0];
            gcode.push(`G0 X${startPoint.x.toFixed(3)} Y${startPoint.y.toFixed(3)} ; Rapid to start`);
            
            // Turn on laser and cut
            gcode.push(`M3 S${laserS} ; Laser on`);
            
            for (let i = 1; i < path.points.length; i++) {
                const point = path.points[i];
                gcode.push(`G1 X${point.x.toFixed(3)} Y${point.y.toFixed(3)} F${feedRate}`);
            }
            
            // Turn off laser
            gcode.push('M3 S0 ; Laser off');
            gcode.push('');
        });
        
        return gcode;
    }
    
    applyToolCompensation(points, radius, outside) {
        // Simple offset algorithm for closed paths
        const offsetPoints = [];
        const direction = outside ? 1 : -1;
        
        for (let i = 0; i < points.length; i++) {
            const prev = points[(i - 1 + points.length) % points.length];
            const curr = points[i];
            const next = points[(i + 1) % points.length];
            
            // Calculate normal vectors
            const v1 = this.normalize({
                x: curr.x - prev.x,
                y: curr.y - prev.y
            });
            
            const v2 = this.normalize({
                x: next.x - curr.x,
                y: next.y - curr.y
            });
            
            // Average normal
            const normal = this.normalize({
                x: -v1.y - v2.y,
                y: v1.x + v2.x
            });
            
            // Offset point
            offsetPoints.push({
                x: curr.x + normal.x * radius * direction,
                y: curr.y + normal.y * radius * direction
            });
        }
        
        return offsetPoints;
    }
    
    normalize(vector) {
        const length = Math.sqrt(vector.x * vector.x + vector.y * vector.y);
        if (length === 0) return { x: 0, y: 0 };
        return {
            x: vector.x / length,
            y: vector.y / length
        };
    }
    
    calculateEstimates(gcode, config) {
        const lines = gcode.split('\n');
        let totalDistance = 0;
        let totalTime = 0;
        let currentX = 0, currentY = 0, currentZ = 0;
        let currentFeed = config.feedRate;
        
        lines.forEach(line => {
            // Remove comments and whitespace
            line = line.split(';')[0].trim();
            if (!line) return;
            
            // Parse G0/G1 moves
            const moveMatch = line.match(/^G[01]\s/);
            if (!moveMatch) {
                // Check for feed rate changes
                const feedMatch = line.match(/F([\d.]+)/);
                if (feedMatch) {
                    currentFeed = parseFloat(feedMatch[1]);
                }
                return;
            }
            
            // Extract coordinates
            const xMatch = line.match(/X([-\d.]+)/);
            const yMatch = line.match(/Y([-\d.]+)/);
            const zMatch = line.match(/Z([-\d.]+)/);
            const fMatch = line.match(/F([-\d.]+)/);
            
            const newX = xMatch ? parseFloat(xMatch[1]) : currentX;
            const newY = yMatch ? parseFloat(yMatch[1]) : currentY;
            const newZ = zMatch ? parseFloat(zMatch[1]) : currentZ;
            
            if (fMatch) {
                currentFeed = parseFloat(fMatch[1]);
            }
            
            // Calculate distance
            const dx = newX - currentX;
            const dy = newY - currentY;
            const dz = newZ - currentZ;
            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
            
            totalDistance += distance;
            
            // Calculate time (distance / feed rate)
            if (currentFeed > 0) {
                totalTime += (distance / currentFeed) * 60; // Convert to seconds
            }
            
            currentX = newX;
            currentY = newY;
            currentZ = newZ;
        });
        
        return {
            distance: totalDistance,
            time: totalTime
        };
    }
    
    // Advanced G-code operations
    optimizePath(paths) {
        // Simple nearest neighbor optimization
        if (paths.length <= 1) return paths;
        
        const optimized = [];
        const remaining = [...paths];
        let current = remaining.shift();
        optimized.push(current);
        
        while (remaining.length > 0) {
            let nearestIndex = 0;
            let nearestDistance = Infinity;
            
            const currentEnd = current.points[current.points.length - 1];
            
            remaining.forEach((path, index) => {
                const pathStart = path.points[0];
                const distance = Math.sqrt(
                    Math.pow(pathStart.x - currentEnd.x, 2) +
                    Math.pow(pathStart.y - currentEnd.y, 2)
                );
                
                if (distance < nearestDistance) {
                    nearestDistance = distance;
                    nearestIndex = index;
                }
            });
            
            current = remaining.splice(nearestIndex, 1)[0];
            optimized.push(current);
        }
        
        return optimized;
    }
    
    addCornerRadius(points, radius) {
        // Add arc fillets to sharp corners
        const smoothed = [];
        
        for (let i = 0; i < points.length; i++) {
            const prev = points[(i - 1 + points.length) % points.length];
            const curr = points[i];
            const next = points[(i + 1) % points.length];
            
            // Calculate angle
            const v1 = { x: curr.x - prev.x, y: curr.y - prev.y };
            const v2 = { x: next.x - curr.x, y: next.y - curr.y };
            
            const angle = Math.acos(
                (v1.x * v2.x + v1.y * v2.y) /
                (Math.sqrt(v1.x * v1.x + v1.y * v1.y) * Math.sqrt(v2.x * v2.x + v2.y * v2.y))
            );
            
            // If sharp corner, add arc
            if (angle < Math.PI * 0.9) {
                // Calculate arc points
                const arcPoints = this.calculateArcPoints(prev, curr, next, radius);
                smoothed.push(...arcPoints);
            } else {
                smoothed.push(curr);
            }
        }
        
        return smoothed;
    }
    
    calculateArcPoints(p1, p2, p3, radius, segments = 8) {
        // Simplified arc calculation
        const points = [];
        
        // Calculate normalized vectors
        const v1 = this.normalize({ x: p2.x - p1.x, y: p2.y - p1.y });
        const v2 = this.normalize({ x: p3.x - p2.x, y: p3.y - p2.y });
        
        // Add arc points
        for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            const x = p2.x + (v1.x * (1 - t) + v2.x * t) * radius;
            const y = p2.y + (v1.y * (1 - t) + v2.y * t) * radius;
            points.push({ x, y });
        }
        
        return points;
    }
    
    // Pocketing (for future implementation)
    generatePocket(boundary, toolDiameter, stepover) {
        // Generates toolpaths to clear the interior of a closed shape
        // This is a placeholder for future implementation
        const paths = [];
        
        // Simple spiral pocket strategy would go here
        console.log('Pocket generation not yet implemented');
        
        return paths;
    }
    
    // Drilling operations
    generateDrillHoles(holes, depth, peckDepth, feedRate, plungeRate, spindleRPM) {
        const gcode = [];
        
        gcode.push('');
        gcode.push('(Drilling Operation)');
        gcode.push(`(Holes: ${holes.length})`);
        gcode.push(`(Depth: ${depth}mm, Peck: ${peckDepth}mm)`);
        gcode.push('');
        
        gcode.push(`M3 S${spindleRPM} ; Start spindle`);
        gcode.push('G4 P2 ; Wait for spindle');
        gcode.push('');
        
        holes.forEach((hole, index) => {
            gcode.push(`(Hole ${index + 1})`);
            gcode.push(`G0 X${hole.x.toFixed(3)} Y${hole.y.toFixed(3)} ; Position`);
            gcode.push('G0 Z2 ; Safe height');
            
            // Peck drilling if peck depth specified
            if (peckDepth > 0) {
                const numPecks = Math.ceil(Math.abs(depth) / peckDepth);
                
                for (let peck = 1; peck <= numPecks; peck++) {
                    const peckDepthValue = -Math.min(peck * peckDepth, Math.abs(depth));
                    gcode.push(`G1 Z${peckDepthValue.toFixed(3)} F${plungeRate} ; Peck ${peck}`);
                    gcode.push('G0 Z1 ; Retract');
                }
            } else {
                // Single plunge
                gcode.push(`G1 Z${depth.toFixed(3)} F${plungeRate} ; Drill`);
            }
            
            gcode.push('G0 Z2 ; Retract');
            gcode.push('');
        });
        
        return gcode.join('\n');
    }
    
    // Text engraving (for future implementation)
    generateTextPath(text, font, size, x, y) {
        // Placeholder for text to path conversion
        console.log('Text engraving not yet implemented');
        return [];
    }
    
    // Export G-code variations
    generateGRBL(paths, config) {
        // Standard GRBL format (default)
        return this.generate(paths, config, config.operationType || 'cnc');
    }
    
    generateLinuxCNC(paths, config) {
        // LinuxCNC compatible format
        let gcode = this.generate(paths, config, config.operationType || 'cnc');
        // Add LinuxCNC specific headers if needed
        return gcode;
    }
    
    generateMach3(paths, config) {
        // Mach3 compatible format
        let gcode = this.generate(paths, config, config.operationType || 'cnc');
        // Add Mach3 specific commands if needed
        return gcode;
    }
}
